---
  # yaml-language-server: $schema=https://json.schemastore.org/github-workflow.json 
name: "Build and Test"
on:
  - pull_request
  - workflow_dispatch
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Build sidecar
        uses: docker/build-push-action@v6
        with:
          push: false
          outputs: type=docker,dest=/tmp/k8s-sidecar.tar
          tags: "kiwigrid/k8s-sidecar:testing"
      - name: Prepare dummy server static resources
        run: |
          cp test/kubelogo.png test/server/static/
      - name: Build dummy server
        uses: docker/build-push-action@v6
        with:
          context: "test/server"
          push: false
          outputs: type=docker,dest=/tmp/dummy-server.tar
          tags: "dummy-server:1.0.0"
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: images
          path: /tmp/*.tar
  test:
    needs:
      - build
    strategy:
      matrix:
        # see https://github.com/kubernetes-sigs/kind/releases for supported k8s versions per kind version
        k8s:
          - maj_min: v1.25
            digest: sha256:6110314339b3b44d10da7d27881849a87e092124afab5956f2e10ecdb463b025
          - maj_min: v1.26
            digest: sha256:1cc15d7b1edd2126ef051e359bf864f37bbcf1568e61be4d2ed1df7a3e87b354
          - maj_min: v1.27
            digest: sha256:3fd82731af34efe19cd54ea5c25e882985bafa2c9baefe14f8deab1737d9fabe
          - maj_min: v1.28
            digest: sha256:45d319897776e11167e4698f6b14938eb4d52eb381d9e3d7a9086c16c69a8110
          - maj_min: v1.29
            digest: sha256:62c0672ba99a4afd7396512848d6fc382906b8f33349ae68fb1dbfe549f70dec
          - maj_min: v1.30
            digest: sha256:17cd608b3971338d9180b00776cb766c50d0a0b6b904ab4ff52fd3fc5c6369bf
          - maj_min: v1.31
            digest: sha256:2cb39f7295fe7eafee0842b1052a599a4fb0f8bcf3f83d96c7f4864c357c6c30
          - maj_min: v1.32
            digest: sha256:c48c62eac5da28cdadcf560d1d8616cfa6783b58f0d94cf63ad1bf49600cb027
    name: "Test on k8s ${{ matrix.k8s.maj_min }}"
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5
      - name: Create k8s Kind Cluster
        # make sure the k8s versions match the kind version of the action version ðŸ¤¯
        uses: helm/kind-action@v1.12.0 # use kind release v0.26.0
        with:
          node_image: kindest/node@${{ matrix.k8s.digest }}
          config: test/kind-config.yaml
          cluster_name: sidecar-testing
          wait: 5m
      - name: Download artifact
        uses: actions/download-artifact@v5
        with:
          name: images
          path: /tmp
      - name: Load images into kind cluster
        shell: bash
        run: |
          kind load image-archive /tmp/k8s-sidecar.tar --name sidecar-testing
          kind load image-archive /tmp/dummy-server.tar --name sidecar-testing
      - name: Install Sidecar and Dummy Server
        id: install_sidecar
        shell: bash
        run: |
          wait_for_pod_ready() {
            while ! kubectl wait --for=condition=ready --timeout=120s pod/$1 2>/dev/null; do
              echo "Waiting for pod $1..."
              sleep 5
            done
            echo "Pod $1 is ready."
          }

          echo "Installing sidecar..."
          kubectl apply -f "test/resources/sidecar.yaml"

          sleep 10

          kubectl get pods

          wait_for_pod_ready "sidecar"
          wait_for_pod_ready "sidecar-healthcheck"
          wait_for_pod_ready "sidecar-basicauth-args"
          wait_for_pod_ready "sidecar-5xx"
          wait_for_pod_ready "sidecar-pythonscript"
          wait_for_pod_ready "sidecar-pythonscript-logfile"
          wait_for_pod_ready "sidecar-pythonscript-resource-name"
          wait_for_pod_ready "sidecar-logtofile-pythonscript"
          wait_for_pod_ready "dummy-server-pod"
      - name: Install Configmaps and Secrets
        id: install_configmaps_and_secrets
        shell: bash
        run: |
          wait_for_pod_log() {
            local pod="$1"
            local pattern="$2"
            local retries=30 # 30 * 5s = 150s timeout
            local count=0
            while [[ $(kubectl logs "$pod" | grep "$pattern") == "" ]]; do
              count=$((count + 1))
              if [[ "$count" -gt "$retries" ]]; then
                echo "Error: Timed out waiting for '$pattern' in logs of pod '$pod'"
                kubectl logs "$pod"
                exit 1
              fi
              echo "waiting 5 more seconds for '$pattern' to appear in logs of pod '$pod'..." && sleep 5
            done
            echo "Pod '$pod' logs contains '$pattern'"
          }
          # because the sidecar pods signal ready state before we actually opened up all watching subprocesses, we wait some more time
          sleep 20
          echo "Installing resources..."
          kubectl apply -f "test/resources/resources.yaml"
          pods=("sidecar" "sidecar-basicauth-args" "sidecar-5xx" "sidecar-pythonscript" "sidecar-pythonscript-logfile")
          resources=("sample-configmap" "sample-secret-binary" "absolute-configmap" "relative-configmap" "change-dir-configmap" "similar-configmap-secret" "url-configmap-500" "url-configmap-basic-auth" "sample-configmap")
          for p in ${pods[*]}; do
            for r in ${resources[*]}; do
              wait_for_pod_log $p $r
            done
          done

          # monitor only specified resources for sidecar-pythonscript-resource-name
          pods=("sidecar-pythonscript-resource-name")
          resources=("sample-configmap" "sample-secret-binary")
          for p in ${pods[*]}; do
            for r in ${resources[*]}; do
              wait_for_pod_log $p $r
            done
          done

          # 10 more seconds after the last thing appeared in the logs.
          sleep 10
      - name: Retrieve pod logs
        shell: bash
        run: |
          mkdir /tmp/logs
          kubectl logs sidecar > /tmp/logs/sidecar.log
          kubectl logs sidecar-healthcheck > /tmp/logs/sidecar-healthcheck.log
          kubectl logs sidecar-basicauth-args > /tmp/logs/sidecar-basicauth-args.log
          kubectl logs sidecar-5xx > /tmp/logs/sidecar-5xx.log
          kubectl logs sidecar-pythonscript > /tmp/logs/sidecar-pythonscript.log
          kubectl logs sidecar-pythonscript-logfile > /tmp/logs/sidecar-pythonscript-logfile.log
          kubectl logs sidecar-pythonscript-resource-name > /tmp/logs/sidecar-pythonscript-resource-name.log
          kubectl logs dummy-server-pod > /tmp/logs/dummy-server.log
      - name: Upload artifacts (pod logs)
        uses: actions/upload-artifact@v4
        with:
          name: pod-logs_${{ matrix.k8s.maj_min }}
          path: /tmp/logs/*
      - name: Download expected files from cluster
        shell: bash
        run: |
          mkdir /tmp/sidecar
          mkdir /tmp/sidecar-5xx
          echo "Downloading resource files from sidecar..."
          kubectl cp sidecar:/tmp/hello.world /tmp/sidecar/hello.world
          kubectl cp sidecar:/tmp/cm-kubelogo.png /tmp/sidecar/cm-kubelogo.png
          kubectl cp sidecar:/tmp/secret-kubelogo.png /tmp/sidecar/secret-kubelogo.png
          kubectl cp sidecar:/tmp/url-downloaded-kubelogo.png /tmp/sidecar/url-downloaded-kubelogo.png
          # script also generates into '/tmp'
          kubectl cp sidecar:/tmp/script_result /tmp/sidecar/script_result
          # absolute path in configmap points to /tmp in 'absolute-configmap'
          kubectl cp sidecar:/tmp/absolute/absolute.txt /tmp/sidecar/absolute.txt
          kubectl cp sidecar:/tmp/relative/relative.txt /tmp/sidecar/relative.txt
          kubectl cp sidecar:/tmp/orig-dir/change-dir.txt /tmp/sidecar/change-dir.txt
          kubectl cp sidecar:/tmp/500.txt /tmp/sidecar/500.txt || true
          kubectl cp sidecar:/tmp/secured.txt /tmp/sidecar/secured.txt
          kubectl cp sidecar:/tmp/similar-configmap.txt /tmp/sidecar/similar-configmap.txt
          kubectl cp sidecar:/tmp/similar-secret.txt /tmp/sidecar/similar-secret.txt

          echo "Downloading resource files from sidecar-basicauth-args pod"
          kubectl cp sidecar-basicauth-args:/tmp/secured.txt /tmp/sidecar-basicauth-args/secured.txt

          echo "Downloading resource files from sidecar-5xx..."
          kubectl cp sidecar-5xx:/tmp-5xx/hello.world /tmp/sidecar-5xx/hello.world
          kubectl cp sidecar-5xx:/tmp-5xx/cm-kubelogo.png /tmp/sidecar-5xx/cm-kubelogo.png
          kubectl cp sidecar-5xx:/tmp-5xx/secret-kubelogo.png /tmp/sidecar-5xx/secret-kubelogo.png
          kubectl cp sidecar-5xx:/tmp-5xx/url-downloaded-kubelogo.png /tmp/sidecar-5xx/url-downloaded-kubelogo.png
          # script also generates into '/tmp'
          kubectl cp sidecar-5xx:/tmp/script_result /tmp/sidecar-5xx/script_result
          # absolute path in configmap points to /tmp in 'absolute-configmap'
          kubectl cp sidecar-5xx:/tmp/absolute/absolute.txt /tmp/sidecar-5xx/absolute.txt
          kubectl cp sidecar-5xx:/tmp-5xx/relative/relative.txt /tmp/sidecar-5xx/relative.txt
          kubectl cp sidecar-5xx:/tmp-5xx/orig-dir/change-dir.txt /tmp/sidecar-5xx/change-dir.txt
          kubectl cp sidecar-5xx:/tmp-5xx/500.txt /tmp/sidecar-5xx/500.txt
          kubectl cp sidecar-5xx:/tmp-5xx/secured.txt /tmp/sidecar-5xx/secured.txt
          kubectl cp sidecar-5xx:/tmp-5xx/similar-configmap.txt /tmp/sidecar-5xx/similar-configmap.txt
          kubectl cp sidecar-5xx:/tmp-5xx/similar-secret.txt /tmp/sidecar-5xx/similar-secret.txt
      - name: Upload artifacts (expected files from cluster)
        uses: actions/upload-artifact@v4
        with:
          name: expected-files_${{ matrix.k8s.maj_min }}
          path: |
            /tmp/sidecar/**
            /tmp/sidecar-5xx/**
      - name: Update Configmaps and Secrets
        shell: bash
        run: |
          sleep 5
          current_time=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          wait_for_pod_log() {
            while [[ $(kubectl logs $1 --since-time ${current_time} | grep $2) == "" ]]; do echo "waiting 5 more seconds for '$2' to appear in logs of pod '$1'..." && sleep 5; done
            echo "Pod '$1' logs contains '$2'"
            local pod="$1"
            local pattern="$2"
            local retries=30 # 30 * 5s = 150s timeout
            local count=0
            while [[ $(kubectl logs "$pod" --since-time ${current_time} | grep "$pattern") == "" ]]; do
              count=$((count + 1))
              if [[ "$count" -gt "$retries" ]]; then
                echo "Error: Timed out waiting for '$pattern' in logs of pod '$pod'"
                kubectl logs "$pod"
                exit 1
              fi
              echo "waiting 5 more seconds for '$pattern' to appear in logs of pod '$pod'..." && sleep 5
            done
            echo "Pod '$pod' logs contains '$pattern'"
          }
          echo "Updating resources..."
          kubectl apply -f "test/resources/change_resources.yaml"
          pods=("sidecar" "sidecar-5xx")
          resources=("sample-configmap" "sample-secret-binary" "absolute-configmap" "relative-configmap" "change-dir-configmap" "similar-configmap-secret" "url-configmap-500" "url-configmap-basic-auth" "sample-configmap")
          for p in ${pods[*]}; do
            for r in ${resources[*]}; do
              wait_for_pod_log $p $r
            done
          done
          # 20 more seconds after the last thing appeared in the logs.
          sleep 20
      - name: Define helper functions
        shell: bash
        run: |
          cat <<'EOF' > /tmp/sidecar_helpers.sh
          check_exists() {
            kubectl exec sidecar -- sh -c "test -e $1" || { echo "$1 missing after update"; return 1; }
          }
          check_not_exists() {
            kubectl exec sidecar -- sh -c "! test -e $1" || { echo "$1 still exists after update"; return 1; }
          }
          check_log_contains() {
            grep "$1" "$2" > /dev/null || { echo "Log $2 does not contain '$1'"; return 1; }
          }
          check_diff() {
            diff "$1" "$2" > /dev/null || { echo "File mismatch: $1 vs $2"; return 1; }
          }
          check_content() {
            echo -n "$1" | diff - "$2" > /dev/null || { echo "$2 mismatch"; return 1; }
          }
          check_empty_or_missing() {
            file="$1"
            if [ ! -s "$file" ]; then
              echo "$file is empty or missing (as expected for error case)"
              return 0
            else
              echo "$file should be empty on request error"
              return 1
            fi
          }
          check_log_count() {
            file="$1"
            pattern="$2"
            expected="$3"
            count=$(grep -c -- "$pattern" "$file")
            if [ "$count" -eq "$expected" ]; then
              echo "$file: found $expected lines matching '$pattern'"
              return 0
            else
              echo "$file: expected $expected, got $count for pattern '$pattern'"
              return 1
            fi
          }
          check_log_min_count() {
            file="$1"
            pattern="$2"
            min_expected="$3"
            count=$(grep -c -- "$pattern" "$file")
            if [ "$min_expected" -gt 0 ] && [ "$count" -ge "$min_expected" ]; then
              echo "$file: found $count lines matching '$pattern' (min $min_expected)"
              return 0
            else
              echo "$file: expected at least $min_expected (>0), got $count for pattern '$pattern'"
              return 1
            fi
          }      
          check_pod_log_count() {
            pod="$1"
            file="$2"
            pattern="$3"
            expected="$4"
            count=$(kubectl exec "$pod" -- sh -c "grep '$pattern' $file | wc -l")
            if [ "$count" -eq "$expected" ]; then
              echo "$file in $pod: found $expected lines matching '$pattern'"
              return 0
            else
              echo "$file in $pod: expected $expected, got $count for pattern '$pattern'"
              return 1
            fi
          }
          check_pod_file_exists() {
            pod="$1"
            file="$2"
            kubectl exec "$pod" -- sh -c "test -e $file" || { echo "$file missing in pod $pod"; return 1; }
          }
          EOF
      - name: Verify sidecar files after initial sync
        shell: bash
        run: |
          source /tmp/sidecar_helpers.sh
          
          check_content "Hello World!" /tmp/sidecar/hello.world
          check_diff test/kubelogo.png /tmp/sidecar/cm-kubelogo.png
          check_diff test/kubelogo.png /tmp/sidecar/secret-kubelogo.png
          check_diff test/kubelogo.png /tmp/sidecar/url-downloaded-kubelogo.png
          check_content "This absolutely exists" /tmp/sidecar/absolute.txt
          check_content "This relatively exists" /tmp/sidecar/relative.txt
          check_content "This change-dir exists" /tmp/sidecar/change-dir.txt
          check_content "I'm very similar" /tmp/sidecar/similar-configmap.txt
          check_content "I'm very similar" /tmp/sidecar/similar-secret.txt
          check_content "allowed" /tmp/sidecar/secured.txt
          check_empty_or_missing /tmp/sidecar/500.txt
          ls /tmp/sidecar/script_result || echo "script_result missing"

          echo "All sidecar files after initial sync verified successfully."
      - name: Verify health server startup
        shell: bash
        run: |
          echo "--- Verifying health server startup in pod sidecar-healthcheck ---"
          source /tmp/sidecar_helpers.sh

          check_log_contains "Uvicorn running" /tmp/logs/sidecar-healthcheck.log
      - name: Verify sidecar-basicauth-args pod file after initial sync
        shell: bash
        run: |
          echo "--- Verifying sidecar-basicauth-args pod file after initial sync ---"
          source /tmp/sidecar_helpers.sh

          check_content "allowed" /tmp/sidecar-basicauth-args/secured.txt          
      - name: Verify sidecar-5xx files after initial sync
        shell: bash
        run: |
          source /tmp/sidecar_helpers.sh

          grep -E '/secured.*Not authenticated' /tmp/logs/sidecar-5xx.log || { echo '"detail":"Not authenticated" not found in sidecar-5xx.log'; exit 1; }
          check_content "Hello World!" /tmp/sidecar-5xx/hello.world
          check_diff test/kubelogo.png /tmp/sidecar-5xx/cm-kubelogo.png
          check_diff test/kubelogo.png /tmp/sidecar-5xx/secret-kubelogo.png
          check_diff test/kubelogo.png /tmp/sidecar-5xx/url-downloaded-kubelogo.png
          check_content "This absolutely exists" /tmp/sidecar-5xx/absolute.txt
          check_content "This relatively exists" /tmp/sidecar-5xx/relative.txt
          check_content "This change-dir exists" /tmp/sidecar-5xx/change-dir.txt
          check_content "I'm very similar" /tmp/sidecar-5xx/similar-configmap.txt
          check_content "I'm very similar" /tmp/sidecar-5xx/similar-secret.txt
          check_empty_or_missing /tmp/sidecar-5xx/500.txt
          ls /tmp/sidecar-5xx/script_result || echo "script_result missing"

          echo "All sidecar-5xx files after initial sync verified successfully."
      - name: Verify sidecar-python logs after initial sync
        shell: bash
        run: |
          # Make sure to update this number this when adding or removing configmap or secrets
          # For log to a file, Need to consider Jobs "Install Configmaps and Secrets" and  "Update Configmaps and Secrets"
          # Total is (10 + 7)
          source /tmp/sidecar_helpers.sh

          check_log_count /tmp/logs/sidecar-pythonscript.log "Hello from python script!" 10
          check_log_count /tmp/logs/sidecar-pythonscript-logfile.log "Hello from python script!" 10
          check_pod_file_exists sidecar-logtofile-pythonscript /opt/logs/sidecar.log
          check_pod_log_count sidecar-logtofile-pythonscript /opt/logs/sidecar.log "Hello from python script!" 17
      - name: Verify sidecar files after update
        shell: bash
        run: |
          source /tmp/sidecar_helpers.sh

          kubectl exec sidecar -- sh -c "ls /tmp/"

          files_not_exist=(
            "/tmp/hello.world"
            "/tmp/cm-kubelogo.png"
            "/tmp/secret-kubelogo.png"
            "/tmp/absolute/absolute.txt"
            "/tmp/relative/relative.txt"
            "/tmp/orig-dir/change-dir.txt"
            "/tmp/similar-configmap.txt"
            "/tmp/similar-secret.txt"
          )
          files_exist=(
            "/tmp/change-hello.world"
            "/tmp/change-cm-kubelogo.png"
            "/tmp/change-secret-kubelogo.png"
            "/tmp/absolute/change-absolute.txt"
            "/tmp/relative/change-relative.txt"
            "/tmp/new-dir/change-dir.txt"
            "/tmp/change-similar-configmap.txt"
            "/tmp/change-similar-secret.txt"
          )

          for f in "${files_not_exist[@]}"; do
            check_not_exists "$f"
          done
          for f in "${files_exist[@]}"; do
            check_exists "$f"
          done

          echo "Sidecar files after update verified (see warnings above if mismatches occurred)."      
      - name: Verify 5xx error handling
        shell: bash
        run: |
          source /tmp/sidecar_helpers.sh
          # Check that the file is empty (or has a defined content) in case of an error.
          check_empty_or_missing /tmp/sidecar/500.txt
          check_empty_or_missing /tmp/sidecar-5xx/500.txt
          # Optional: Check logs for error messages.
          check_log_contains "Max retries exceeded for URL" /tmp/logs/sidecar.log
      - name: Verify liveness probe on watcher process failure
        shell: bash
        run: |
          source /tmp/sidecar_helpers.sh
          echo "--- Verifying liveness probe ---"
          initial_restarts=$(kubectl get pod sidecar -o jsonpath='{.status.containerStatuses[0].restartCount}')
          echo "Initial restart count for 'sidecar' pod: $initial_restarts"

          echo "Killing watcher process inside 'sidecar' pod..."
          # The watcher processes run _watch_resource_loop. We kill one of them.
          # The main process is PID 1, the watchers are its children. We kill all children of PID 1.
          kubectl exec sidecar -- pkill -P 1

          echo "Waiting for liveness probe to fail and container to restart..."
          for i in {1..20}; do
            current_restarts=$(kubectl get pod sidecar -o jsonpath='{.status.containerStatuses[0].restartCount}' || echo "$initial_restarts")
            if [ "$current_restarts" -gt "$initial_restarts" ]; then
              echo "Container successfully restarted. Restart count is now $current_restarts."
              exit 0
            fi
            echo "Waited $((i*5)) seconds. Current restarts: $current_restarts. Waiting..."
            sleep 5
          done

          echo "Error: Timed out waiting for container to restart. Liveness probe did not trigger a restart as expected."
          exit 1
